{"name":"UserSDJpaServiceTest.java","path":"service/src/test/java/com/myhome/services/unit/UserSDJpaServiceTest.java","content":{"structured":{"description":"","items":[{"id":"ba1ece1c-c48d-4c5d-9805-ea0b214f0999","ancestors":[],"type":"function","name":"setUp","location":{"offset":" ","indent":2,"insert":68,"start":68},"returns":false,"params":[],"code":"@BeforeEach\n  void setUp() {\n    MockitoAnnotations.initMocks(this);\n  }","skip":false,"length":4,"comment":{"description":"sets up mock objects using the `MockitoAnnotations.initMocks` method, preparing the environment for testing.","params":[],"returns":null}},{"id":"472947d6-059e-4b58-8e9b-30c440dc06c5","ancestors":[],"type":"function","name":"createUserSuccess","location":{"offset":" ","indent":2,"insert":73,"start":73},"returns":false,"params":[],"code":"@Test\n  void createUserSuccess() {\n    // given\n    UserDto request = getDefaultUserDtoRequest();\n    User resultUser = getUserFromDto(request);\n    UserDto response = UserDto.builder()\n        .id(resultUser.getId())\n        .userId(resultUser.getUserId())\n        .name(resultUser.getName())\n        .encryptedPassword(resultUser.getEncryptedPassword())\n        .communityIds(new HashSet<>())\n        .build();\n    SecurityToken emailConfirmToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, \"token\", resultUser);\n\n    given(userRepository.findByEmail(request.getEmail()))\n        .willReturn(null);\n    given(passwordEncoder.encode(request.getPassword()))\n        .willReturn(request.getPassword());\n    given(userMapper.userDtoToUser(request))\n        .willReturn(resultUser);\n    given(userRepository.save(resultUser))\n        .willReturn(resultUser);\n    given(userMapper.userToUserDto(resultUser))\n        .willReturn(response);\n    given(securityTokenService.createEmailConfirmToken(resultUser))\n        .willReturn(emailConfirmToken);\n\n    // when\n    Optional<UserDto> createdUserDtoOptional = userService.createUser(request);\n\n    // then\n    assertTrue(createdUserDtoOptional.isPresent());\n    UserDto createdUserDto = createdUserDtoOptional.get();\n    assertEquals(response, createdUserDto);\n    assertEquals(0, createdUserDto.getCommunityIds().size());\n    verify(userRepository).findByEmail(request.getEmail());\n    verify(passwordEncoder).encode(request.getPassword());\n    verify(userRepository).save(resultUser);\n    verify(securityTokenService).createEmailConfirmToken(resultUser);\n  }","skip":false,"length":41,"comment":{"description":"creates a new user based on a provided request, saves it to the database, and generates an email confirmation token.","params":[],"returns":null}},{"id":"f5518ce2-c1f3-4cb2-97ad-93ab676b4508","ancestors":[],"type":"function","name":"createUserEmailExists","location":{"offset":" ","indent":2,"insert":115,"start":115},"returns":false,"params":[],"code":"@Test\n  void createUserEmailExists() {\n    // given\n    UserDto request = getDefaultUserDtoRequest();\n    User user = getUserFromDto(request);\n\n    given(userRepository.findByEmail(request.getEmail()))\n        .willReturn(user);\n\n    // when\n    Optional<UserDto> createdUserDto = userService.createUser(request);\n\n    // then\n    assertFalse(createdUserDto.isPresent());\n    verify(userRepository).findByEmail(request.getEmail());\n  }","skip":false,"length":16,"comment":{"description":"tests whether creating a user with an existing email address returns false and calls the `verify` method on the `userRepository` to simulate the query being executed.","params":[],"returns":null}},{"id":"5f843b50-1cf5-40da-ba8b-8669542b7efb","ancestors":[],"type":"function","name":"getUserDetailsSuccess","location":{"offset":" ","indent":2,"insert":132,"start":132},"returns":false,"params":[],"code":"@Test\n  void getUserDetailsSuccess() {\n    // given\n    UserDto userDto = getDefaultUserDtoRequest();\n    User user = getUserFromDto(userDto);\n\n    given(userRepository.findByUserIdWithCommunities(USER_ID))\n        .willReturn(Optional.of(user));\n    given(userMapper.userToUserDto(user))\n        .willReturn(userDto);\n\n    // when\n    Optional<UserDto> createdUserDtoOptional = userService.getUserDetails(USER_ID);\n\n    // then\n    assertTrue(createdUserDtoOptional.isPresent());\n    UserDto createdUserDto = createdUserDtoOptional.get();\n    assertEquals(userDto, createdUserDto);\n    assertEquals(0, createdUserDto.getCommunityIds().size());\n    verify(userRepository).findByUserIdWithCommunities(USER_ID);\n  }","skip":false,"length":21,"comment":{"description":"tests the user service's ability to retrieve a user's details from the repository and map them to a UserDto object. It verifies that the resulting UserDto object matches the expected default user Dto, has no community IDs, and calls the verify method on the repository.","params":[],"returns":null}},{"id":"f5e0e006-f64a-498e-94e6-d84b0f455f24","ancestors":[],"type":"function","name":"getUserDetailsSuccessWithCommunityIds","location":{"offset":" ","indent":2,"insert":154,"start":154},"returns":false,"params":[],"code":"@Test\n  void getUserDetailsSuccessWithCommunityIds() {\n    // given\n    UserDto userDto = getDefaultUserDtoRequest();\n    User user = new User(userDto.getName(), userDto.getUserId(), userDto.getEmail(), false,\n        userDto.getEncryptedPassword(), new HashSet<>(), null);\n\n    Community firstCommunity = TestUtils.CommunityHelpers.getTestCommunity(user);\n    Community secCommunity = TestUtils.CommunityHelpers.getTestCommunity(user);\n\n    Set<Community> communities =\n        Stream.of(firstCommunity, secCommunity).collect(Collectors.toSet());\n\n    Set<String> communitiesIds = communities\n        .stream()\n        .map(community -> community.getCommunityId())\n        .collect(Collectors.toSet());\n\n    given(userRepository.findByUserIdWithCommunities(USER_ID))\n        .willReturn(Optional.of(user));\n    given(userMapper.userToUserDto(user))\n        .willReturn(userDto);\n\n    // when\n    Optional<UserDto> createdUserDtoOptional = userService.getUserDetails(USER_ID);\n\n    // then\n    assertTrue(createdUserDtoOptional.isPresent());\n    UserDto createdUserDto = createdUserDtoOptional.get();\n    assertEquals(userDto, createdUserDto);\n    assertEquals(communitiesIds, createdUserDto.getCommunityIds());\n    verify(userRepository).findByUserIdWithCommunities(USER_ID);\n  }","skip":false,"length":33,"comment":{"description":"verifies that a user's details can be retrieved successfully along with their community IDs using the `userRepository` and `userMapper`.","params":[],"returns":null}},{"id":"55f033fd-16f5-4f1d-b647-3299c8a2b5da","ancestors":[],"type":"function","name":"getUserDetailsNotFound","location":{"offset":" ","indent":2,"insert":188,"start":188},"returns":false,"params":[],"code":"@Test\n  void getUserDetailsNotFound() {\n    // given\n    given(userRepository.findByUserIdWithCommunities(USER_ID))\n        .willReturn(Optional.empty());\n\n    // when\n    Optional<UserDto> createdUserDto = userService.getUserDetails(USER_ID);\n\n    // then\n    assertFalse(createdUserDto.isPresent());\n    verify(userRepository).findByUserIdWithCommunities(USER_ID);\n  }","skip":false,"length":13,"comment":{"description":"tests whether the `getUserDetails` method returns an empty Optional when the user with the given ID does not exist in the repository.","params":[],"returns":null}},{"id":"a6029352-16af-4cb5-992f-ae74d197ac89","ancestors":[],"type":"function","name":"confirmEmail","location":{"offset":" ","indent":2,"insert":202,"start":202},"returns":false,"params":[],"code":"@Test\n  void confirmEmail() {\n    // given\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN,\n            user);\n    user.getUserTokens().add(testSecurityToken);\n    given(securityTokenService.useToken(testSecurityToken))\n        .willReturn(testSecurityToken);\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n    //    given(mailService.sendAccountConfirmed(user))\n    //        .willReturn(true);\n\n    // when\n    boolean emailConfirmed =\n        userService.confirmEmail(user.getUserId(), testSecurityToken.getToken());\n\n    // then\n    assertTrue(emailConfirmed);\n    assertTrue(user.isEmailConfirmed());\n    verify(securityTokenService).useToken(testSecurityToken);\n    verify(userRepository).save(user);\n    //    verify(mailService).sendAccountConfirmed(user);\n  }","skip":false,"length":26,"comment":{"description":"verifies an email address is confirmed for a user by sending a confirmation request, retrieving the token response, and saving the user's updated status in the database.","params":[],"returns":null}},{"id":"04d22ef8-ca1e-46f1-b30e-81ea1b4749bf","ancestors":[],"type":"function","name":"confirmEmailWrongToken","location":{"offset":" ","indent":2,"insert":229,"start":229},"returns":false,"params":[],"code":"@Test\n  void confirmEmailWrongToken() {\n    // given\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN,\n            user);\n    user.getUserTokens().add(testSecurityToken);\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean emailConfirmed = userService.confirmEmail(user.getUserId(), \"wrong-token\");\n\n    // then\n    assertFalse(emailConfirmed);\n    assertFalse(user.isEmailConfirmed());\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(securityTokenService);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":21,"comment":{"description":"tests the email confirmation process for a user when an incorrect token is provided. It verifies that the email is not confirmed and fails to save the user in the repository.","params":[],"returns":null}},{"id":"06fd44ce-2250-44b9-a03b-88ebb21d3099","ancestors":[],"type":"function","name":"confirmEmailUsedToken","location":{"offset":" ","indent":2,"insert":251,"start":251},"returns":false,"params":[],"code":"@Test\n  void confirmEmailUsedToken() {\n    // given\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN,\n            user);\n    testSecurityToken.setUsed(true);\n    user.getUserTokens().add(testSecurityToken);\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean emailConfirmed =\n        userService.confirmEmail(user.getUserId(), testSecurityToken.getToken());\n\n    // then\n    assertFalse(emailConfirmed);\n    assertFalse(user.isEmailConfirmed());\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(securityTokenService);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":23,"comment":{"description":"tests whether an email is confirmed using a token that has been marked as used by the user.","params":[],"returns":null}},{"id":"8dfe2c46-301a-494c-892d-efe28307b57c","ancestors":[],"type":"function","name":"confirmEmailNoToken","location":{"offset":" ","indent":2,"insert":275,"start":275},"returns":false,"params":[],"code":"@Test\n  void confirmEmailNoToken() {\n    // given\n    User user = getDefaultUser();\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean emailConfirmed = userService.confirmEmail(user.getUserId(), \"any-token\");\n\n    // then\n    assertFalse(emailConfirmed);\n    assertFalse(user.isEmailConfirmed());\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(securityTokenService);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":17,"comment":{"description":"tests whether a user's email can be confirmed without providing a token. It does this by attempting to confirm the user's email and verifying that it returns false, as well as checking that the user's email is not marked as confirmed and that no interactions occurred with the `securityTokenService` or `mailService`.","params":[],"returns":null}},{"id":"8e139ee0-ab63-42e3-a07c-8764b0b42084","ancestors":[],"type":"function","name":"confirmEmailAlreadyConfirmed","location":{"offset":" ","indent":2,"insert":293,"start":293},"returns":false,"params":[],"code":"@Test\n  void confirmEmailAlreadyConfirmed() {\n    // given\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN,\n            user);\n    user.getUserTokens().add(testSecurityToken);\n    user.setEmailConfirmed(true);\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean emailConfirmed =\n        userService.confirmEmail(user.getUserId(), testSecurityToken.getToken());\n\n    // then\n    assertFalse(emailConfirmed);\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(securityTokenService);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":22,"comment":{"description":"verifies that an email address is already confirmed by attempting to confirm it with a previously generated security token and checking if the user is updated in the repository.","params":[],"returns":null}},{"id":"5b393a42-f6da-4c0d-889c-33accbb6eaca","ancestors":[],"type":"function","name":"findUserByEmailSuccess","location":{"offset":" ","indent":2,"insert":316,"start":316},"returns":false,"params":[],"code":"@Test\n  void findUserByEmailSuccess() {\n    // given\n    UserDto userDto = getDefaultUserDtoRequest();\n    User user = getUserFromDto(userDto);\n\n    given(userRepository.findByEmail(USER_EMAIL))\n        .willReturn(user);\n    given(userMapper.userToUserDto(user))\n        .willReturn(userDto);\n\n    // when\n    Optional<UserDto> resultUserDtoOptional = userService.findUserByEmail(USER_EMAIL);\n\n    // then\n    assertTrue(resultUserDtoOptional.isPresent());\n    UserDto createdUserDto = resultUserDtoOptional.get();\n    assertEquals(userDto, createdUserDto);\n    assertEquals(0, createdUserDto.getCommunityIds().size());\n    verify(userRepository).findByEmail(USER_EMAIL);\n  }","skip":false,"length":21,"comment":{"description":"verifies that user service can successfully find a user by email using repository and mapper methods.","params":[],"returns":null}},{"id":"78414650-039c-4232-967c-8211097bf6d8","ancestors":[],"type":"function","name":"findUserByEmailSuccessWithCommunityIds","location":{"offset":" ","indent":2,"insert":338,"start":338},"returns":false,"params":[],"code":"@Test\n  void findUserByEmailSuccessWithCommunityIds() {\n    // given\n    UserDto userDto = getDefaultUserDtoRequest();\n    User user = getUserFromDto(userDto);\n\n    Community firstCommunity = TestUtils.CommunityHelpers.getTestCommunity(user);\n    Community secCommunity = TestUtils.CommunityHelpers.getTestCommunity(user);\n\n    Set<Community> communities =\n        Stream.of(firstCommunity, secCommunity).collect(Collectors.toSet());\n\n    Set<String> communitiesIds = communities\n        .stream()\n        .map(Community::getCommunityId)\n        .collect(Collectors.toSet());\n\n    given(userRepository.findByEmail(USER_EMAIL))\n        .willReturn(user);\n    given(userMapper.userToUserDto(user))\n        .willReturn(userDto);\n\n    // when\n    Optional<UserDto> resultUserDtoOptional = userService.findUserByEmail(USER_EMAIL);\n\n    // then\n    assertTrue(resultUserDtoOptional.isPresent());\n    UserDto createdUserDto = resultUserDtoOptional.get();\n    assertEquals(userDto, createdUserDto);\n    assertEquals(communitiesIds, createdUserDto.getCommunityIds());\n    verify(userRepository).findByEmail(USER_EMAIL);\n  }","skip":false,"length":32,"comment":{"description":"finds a user by email and returns their communities IDs in a set. It uses mocking to verify the calls made to the user repository and mapper.","params":[],"returns":null}},{"id":"fc474066-a055-4ab1-93ec-b4217c941b22","ancestors":[],"type":"function","name":"findUserByEmailNotFound","location":{"offset":" ","indent":2,"insert":371,"start":371},"returns":false,"params":[],"code":"@Test\n  void findUserByEmailNotFound() {\n    // given\n    given(userRepository.findByEmail(USER_EMAIL))\n        .willReturn(null);\n\n    // when\n    Optional<UserDto> resultUserDtoOptional = userService.findUserByEmail(USER_EMAIL);\n\n    // then\n    assertFalse(resultUserDtoOptional.isPresent());\n    verify(userRepository).findByEmail(USER_EMAIL);\n  }","skip":false,"length":13,"comment":{"description":"verifies that a user is not found by their email address in the repository, and asserts that the optional result from the service call is empty.","params":[],"returns":null}},{"id":"51cd0c3a-53bb-4410-9906-8c9734758444","ancestors":[],"type":"function","name":"requestResetPassword","location":{"offset":" ","indent":2,"insert":385,"start":385},"returns":false,"params":[],"code":"@Test\n  void requestResetPassword() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, null);\n    given(securityTokenService.createPasswordResetToken(user))\n        .willReturn(testSecurityToken);\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n    given(mailService.sendPasswordRecoverCode(user, testSecurityToken.getToken()))\n        .willReturn(true);\n\n    // when\n    boolean resetRequested = userService.requestResetPassword(forgotPasswordRequest);\n\n    // then\n    assertTrue(resetRequested);\n    assertEquals(getUserSecurityToken(user, SecurityTokenType.RESET), testSecurityToken);\n    verify(securityTokenService).createPasswordResetToken(user);\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verify(userRepository).save(user);\n    verify(mailService).sendPasswordRecoverCode(user, testSecurityToken.getToken());\n  }","skip":false,"length":25,"comment":{"description":"resets a user's password using their email address and a security token sent via mail. It creates a new security token, saves the updated user record, sends an email with a password recover code, and verifies related method calls.","params":[],"returns":null}},{"id":"e0ab1b56-e0ff-45f5-ba0f-69de2c5172cf","ancestors":[],"type":"function","name":"requestResetPasswordUserNotExists","location":{"offset":" ","indent":2,"insert":411,"start":411},"returns":false,"params":[],"code":"@Test\n  void requestResetPasswordUserNotExists() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user);\n    given(securityTokenService.createPasswordResetToken(user))\n        .willReturn(testSecurityToken);\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.empty());\n\n    // when\n    boolean resetRequested = userService.requestResetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(resetRequested);\n    assertNotEquals(getUserSecurityToken(user, SecurityTokenType.RESET), testSecurityToken);\n    verifyNoInteractions(securityTokenService);\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":23,"comment":{"description":"verifies that a password reset request is not triggered when the user does not exist in the system.","params":[],"returns":null}},{"id":"ec586e7c-8f95-41b0-852d-c199f548cbb3","ancestors":[],"type":"function","name":"resetPassword","location":{"offset":" ","indent":2,"insert":435,"start":435},"returns":false,"params":[],"code":"@Test\n  void resetPassword() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user);\n    user.getUserTokens().add(testSecurityToken);\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n    given(passwordEncoder.encode(forgotPasswordRequest.getNewPassword()))\n        .willReturn(forgotPasswordRequest.getNewPassword());\n    when(userRepository.save(user))\n        .then(returnsFirstArg());\n    given(mailService.sendPasswordSuccessfullyChanged(user))\n        .willReturn(true);\n    given(securityTokenService.useToken(testSecurityToken))\n        .willReturn(testSecurityToken);\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertTrue(passwordChanged);\n    assertEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verify(passwordEncoder).encode(forgotPasswordRequest.getNewPassword());\n    verify(mailService).sendPasswordSuccessfullyChanged(user);\n    verify(securityTokenService).useToken(testSecurityToken);\n  }","skip":false,"length":30,"comment":{"description":"resets a user's password by generating a new security token, encoder the new password, and send a password change confirmation email. It also saves the updated user object in the repository and returns true if the password was successfully changed.","params":[],"returns":null}},{"id":"40356c09-f866-4180-9789-b53fdecc0f8e","ancestors":[],"type":"function","name":"resetPasswordUserNotExists","location":{"offset":" ","indent":2,"insert":466,"start":466},"returns":false,"params":[],"code":"@Test\n  void resetPasswordUserNotExists() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user);\n    user.getUserTokens().add(testSecurityToken);\n    ;\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.empty());\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(passwordChanged);\n    assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verifyNoInteractions(securityTokenRepository);\n    verifyNoInteractions(passwordEncoder);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":23,"comment":{"description":"verifies that a user does not exist when attempting to reset their password, and returns false and the original password is not updated.","params":[],"returns":null}},{"id":"61bdd540-b01f-44d0-a5cc-2824f4b7bcd3","ancestors":[],"type":"function","name":"resetPasswordTokenExpired","location":{"offset":" ","indent":2,"insert":490,"start":490},"returns":false,"params":[],"code":"@Test\n  void resetPasswordTokenExpired() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    SecurityToken testSecurityToken = getExpiredTestToken();\n    User user = getDefaultUser();\n    user.getUserTokens().add(testSecurityToken);\n    ;\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(passwordChanged);\n    assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    assertFalse(getUserSecurityToken(user, SecurityTokenType.RESET).isUsed());\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verifyNoInteractions(securityTokenRepository);\n    verifyNoInteractions(passwordEncoder);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":23,"comment":{"description":"tests whether resetting a password for an expired security token results in the expected behavior, including failure to change the password and marking the security token as unused.","params":[],"returns":null}},{"id":"59c10c5d-0d01-4dd9-99f2-af922d5a7364","ancestors":[],"type":"function","name":"resetPasswordTokenNotExists","location":{"offset":" ","indent":2,"insert":514,"start":514},"returns":false,"params":[],"code":"@Test\n  void resetPasswordTokenNotExists() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(passwordChanged);\n    assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verifyNoInteractions(securityTokenRepository);\n    verifyNoInteractions(passwordEncoder);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":19,"comment":{"description":"tests the user service's ability to reset a password for an email address that does not have a password reset token associated with it.","params":[],"returns":null}},{"id":"5b88aef7-1551-413f-b769-1b544400af68","ancestors":[],"type":"function","name":"resetPasswordTokenNotMatches","location":{"offset":" ","indent":2,"insert":534,"start":534},"returns":false,"params":[],"code":"@Test\n  void resetPasswordTokenNotMatches() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, null);\n    testSecurityToken.setToken(\"wrong-token\");\n    User user = getDefaultUser();\n    user.getUserTokens().add(testSecurityToken);\n    ;\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(passwordChanged);\n    assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    assertNotNull(getUserSecurityToken(user, SecurityTokenType.RESET));\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verifyNoInteractions(securityTokenRepository);\n    verifyNoInteractions(passwordEncoder);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":25,"comment":{"description":"verifies that the provided token does not match the expected reset password token, and returns false when attempting to reset the password using the incorrect token.","params":[],"returns":null}},{"id":"640f344d-1418-4778-bb5e-d994560206b8","ancestors":[],"type":"function","name":"getDefaultUserDtoRequest","location":{"offset":" ","indent":2,"insert":560,"start":560},"returns":"UserDto","params":[],"code":"private UserDto getDefaultUserDtoRequest() {\n    return UserDto.builder()\n        .userId(USER_ID)\n        .name(USERNAME)\n        .email(USER_EMAIL)\n        .encryptedPassword(USER_PASSWORD)\n        .communityIds(new HashSet<>())\n        .build();\n  }","skip":false,"length":9,"comment":{"description":"generates a default UserDto instance with predefined fields based on user-specific values for user ID, name, email, password, and community IDs.","params":[],"returns":{"type":"UserDto","description":"a `UserDto` object populated with default values for a user."}}},{"id":"52bf6c2e-e8ee-4468-9c9a-aed8ee92e597","ancestors":[],"type":"function","name":"getUserFromDto","location":{"offset":" ","indent":2,"insert":570,"start":570},"returns":"User","params":[{"name":"request","type":"UserDto"}],"code":"private User getUserFromDto(UserDto request) {\n    return new User(\n        request.getName(),\n        request.getUserId(),\n        request.getEmail(),\n        false,\n        request.getEncryptedPassword(),\n        new HashSet<>(),\n        new HashSet<>()\n    );\n  }","skip":false,"length":11,"comment":{"description":"converts a `UserDto` object into a `User` object by extracting name, user ID, email, and password from the DTO, and setting encrypted password and hash sets accordingly.","params":[{"name":"request","type":"UserDto","description":"`UserDto` object that contains the user's details, which are then used to create a new `User` object."}],"returns":{"type":"User","description":"a `User` object with fields for name, user ID, email, and encrypted password."}}},{"id":"2a4ddf6b-ac30-41bb-8e7f-a9e9012238f8","ancestors":[],"type":"function","name":"getUserSecurityToken","location":{"offset":" ","indent":2,"insert":582,"start":582},"returns":"SecurityToken","params":[{"name":"user","type":"User"},{"name":"tokenType","type":"SecurityTokenType"}],"code":"private SecurityToken getUserSecurityToken(User user, SecurityTokenType tokenType) {\n    return user.getUserTokens()\n        .stream()\n        .filter(token -> token.getTokenType() == tokenType)\n        .findFirst()\n        .orElse(null);\n  }","skip":false,"length":7,"comment":{"description":"retrieves a user's security token based on the specified `tokenType`. It streams through the user's token collection, filters by token type, and returns the first matching token or `null` if none found.","params":[{"name":"user","type":"User","description":"user for whom the security token is being retrieved, and it is used to filter the user's token collection to find the matching token of the required type."},{"name":"tokenType","type":"SecurityTokenType","description":"type of security token to be retrieved, and it is used to filter the stream of user tokens to only include tokens with the specified type."}],"returns":{"type":"SecurityToken","description":"a `SecurityToken` object representing the user's security token of the specified type, or `null` if no such token exists."}}},{"id":"fb950578-9119-422b-ac07-bcee46f17a51","ancestors":[],"type":"function","name":"getDefaultUser","location":{"offset":" ","indent":2,"insert":590,"start":590},"returns":"User","params":[],"code":"private User getDefaultUser() {\n    return getUserFromDto(getDefaultUserDtoRequest());\n  }","skip":false,"length":3,"comment":{"description":"retrieves a default user object from a request containing the necessary details for the user, such as name and email address.","params":[],"returns":{"type":"User","description":"a `User` object representing the default user for the application."}}},{"id":"117faab3-3a72-48ec-a8b4-29a93fb1ff56","ancestors":[],"type":"function","name":"getForgotPasswordRequest","location":{"offset":" ","indent":2,"insert":594,"start":594},"returns":"ForgotPasswordRequest","params":[],"code":"private ForgotPasswordRequest getForgotPasswordRequest() {\n    ForgotPasswordRequest request = new ForgotPasswordRequest();\n    request.setEmail(USER_EMAIL);\n    request.setNewPassword(NEW_USER_PASSWORD);\n    request.setToken(PASSWORD_RESET_TOKEN);\n    return request;\n  }","skip":false,"length":7,"comment":{"description":"creates a new `ForgotPasswordRequest` object with specified email, new password and token for password reset.","params":[],"returns":{"type":"ForgotPasswordRequest","description":"a `ForgotPasswordRequest` object containing the user's email, new password, and password reset token."}}},{"id":"3ca515d6-c6c8-4955-9992-00b825a7d3e9","ancestors":[],"type":"function","name":"getExpiredTestToken","location":{"offset":" ","indent":2,"insert":602,"start":602},"returns":"SecurityToken","params":[],"code":"private SecurityToken getExpiredTestToken() {\n    return new SecurityToken(SecurityTokenType.RESET, PASSWORD_RESET_TOKEN, LocalDate.now(),\n        LocalDate.now().minusDays(TOKEN_LIFETIME.toDays()), false, null);\n  }","skip":false,"length":4,"comment":{"description":"generates a test security token with an expiration date set to the current date minus a specified number of days, and sets the token status to invalid.","params":[],"returns":{"type":"SecurityToken","description":"a SecurityToken object representing an expired token."}}},{"id":"3874a7c6-dd55-4584-9401-2a0c2d97a797","ancestors":[],"type":"function","name":"getSecurityToken","location":{"offset":" ","indent":2,"insert":607,"start":607},"returns":"SecurityToken","params":[{"name":"tokenType","type":"SecurityTokenType"},{"name":"lifetime","type":"Duration"},{"name":"token","type":"String"},{"name":"user","type":"User"}],"code":"private SecurityToken getSecurityToken(SecurityTokenType tokenType, Duration lifetime,\n      String token, User user) {\n    LocalDate expireDate = LocalDate.now().plusDays(lifetime.toDays());\n    return new SecurityToken(tokenType, token, LocalDate.now(), expireDate, false, user);\n  }","skip":false,"length":5,"comment":{"description":"generates a new security token instance with specified type, token, and lifetime. It also sets the expiration date to a future date based on the provided lifetime.","params":[{"name":"tokenType","type":"SecurityTokenType","description":"type of security token being generated, which determines the format and content of the token."},{"name":"lifetime","type":"Duration","description":"duration of validity for the security token, which determines when the token will expire."},{"name":"token","type":"String","description":"128-bit security token value to be generated by the `getSecurityToken` function."},{"name":"user","type":"User","description":"user who will use the generated security token."}],"returns":{"type":"SecurityToken","description":"a new security token instance with the specified type, token, and expiration date."}}},{"id":"2f0451b4-1388-40c0-957a-6f02490a5e4b","ancestors":[],"type":"function","name":"getSecurityToken","location":{"offset":" ","indent":2,"insert":613,"start":613},"returns":"SecurityToken","params":[{"name":"tokenType","type":"SecurityTokenType"},{"name":"token","type":"String"},{"name":"user","type":"User"}],"code":"private SecurityToken getSecurityToken(SecurityTokenType tokenType, String token, User user) {\n    LocalDate expireDate = LocalDate.now().plusDays(Duration.ofDays(1).toDays());\n    return new SecurityToken(tokenType, token, LocalDate.now(), expireDate, false, user);\n  }","skip":false,"length":4,"comment":{"description":"creates a new security token with the specified type and token value, sets the expiration date to one day from the current date, and sets the token as invalid for login purposes.","params":[{"name":"tokenType","type":"SecurityTokenType","description":"type of security token being generated, which is used to determine the characteristics of the token such as its validity period and user affiliation."},{"name":"token","type":"String","description":"16-character alphanumeric string that is used to identify the security token."},{"name":"user","type":"User","description":"user who will use the security token."}],"returns":{"type":"SecurityToken","description":"a new `SecurityToken` object representing the specified type of token with the provided token value and expiration date."}}}]}}}